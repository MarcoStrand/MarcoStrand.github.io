<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MarcoStrand&#39;s Blog</title>
  
  
  <link href="http://localhost:4000/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2023-01-31T16:03:38.595Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>Liu Hanzhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript学习笔记——作用域与预解析</title>
    <link href="http://localhost:4000/2023/02/01/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://localhost:4000/2023/02/01/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%A2%84%E8%A7%A3%E6%9E%90/</id>
    <published>2023-01-31T16:01:50.000Z</published>
    <updated>2023-01-31T16:03:38.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS作用域"><a href="#JS作用域" class="headerlink" title="JS作用域"></a>JS作用域</h1><h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h2><p>就是代码名字（变量）在某个范围内起作用，目的是为了提高程序的可靠性，更重要的是减少命名冲突</p><p>js作用域（es6）之前：全局作用域和局部作用域</p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p><strong>整个script标签</strong> 或者 是一个单独的js文件</p><h3 id="局部作用域（函数作用域）"><a href="#局部作用域（函数作用域）" class="headerlink" title="局部作用域（函数作用域）"></a>局部作用域（函数作用域）</h3><p><strong>在函数内部</strong>就是局部作用域 这个代码的名字只在函数内部起效果</p><h2 id="2-变量的作用域"><a href="#2-变量的作用域" class="headerlink" title="2. 变量的作用域"></a>2. 变量的作用域</h2><p>根据作用域的不同，分别全局变量和局部变量</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在全局作用域下的变量</p><p>注意：</p><ul><li>如果在函数内部没有声明直接赋值的变量也属于全局变量</li></ul><p>示例：</p><p>  <code>function fun()&#123;</code></p><p>​      <code>var num1 = 10;</code></p><p>​      <code>num2 = 20;  //函数内部没有声明直接赋值的变量</code></p><p>​    <code>&#125;</code></p><p>​    <code>fun();</code></p><p>​    <code>console.log(num1);  //运行错误，因为num1是一个局部变量，无法全局调用</code></p><p>​    <code>console.log(num2);  //20 运行成功，因为num2在函数内部没有声明，按全局变量处理</code></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在局部作用域下声明的变量叫做局部变量</p><p>注意：</p><ul><li><p>局部变量只能在该函数内部使用</p></li><li><p>函数内部var声明的变量是局部变量</p></li><li><p>函数的形参实际上就是局部变量</p></li></ul><h3 id="从执行效率来看全局变量和局部变量"><a href="#从执行效率来看全局变量和局部变量" class="headerlink" title="从执行效率来看全局变量和局部变量"></a>从执行效率来看全局变量和局部变量</h3><ul><li>全局变量只有浏览器关闭的时候才会销毁，比较占内存空间</li><li>局部变量当我们执行完毕就会销毁，比较节约资源</li></ul><h2 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3. 作用域链"></a>3. 作用域链</h2><p>内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构我们称为作用域链</p><p>就近原则</p><img src="/2023/02/01/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%A2%84%E8%A7%A3%E6%9E%90/image-20230131165921665.png" style="zoom:80%;"><p>num输出值为20，一层一层向上找</p><ul><li><p>只要是代码，就只要有一个作用域</p></li><li><p>写在函数内部的局部作用域</p></li><li><p>如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域</p><img src="/2023/02/01/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%A2%84%E8%A7%A3%E6%9E%90/image-20230131165250172.png" style="zoom:80%;"></li><li><p>根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作用域链</p></li></ul><h1 id="JS预解析"><a href="#JS预解析" class="headerlink" title="JS预解析"></a>JS预解析</h1><h2 id="1-预解析"><a href="#1-预解析" class="headerlink" title="1.预解析"></a>1.预解析</h2><p>js代码是通过浏览器中的js解析器来执行的，js引擎运行js分为两步：预解析 代码执行</p><p><strong>预解析</strong>：js引擎会把js所有var 还有function提升到当前作用于的最前面</p><p><strong>代码执行</strong>：按照代码书写的顺序从上往下执行</p><p>预解析分为：</p><h3 id="变量预解析（变量提升）"><a href="#变量预解析（变量提升）" class="headerlink" title="变量预解析（变量提升）"></a>变量预解析（变量提升）</h3><p>​       就是把所有的变量声明提升到<strong>当前作用域</strong>的最前面，不提升 赋值操作</p><img src="/2023/02/01/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%A2%84%E8%A7%A3%E6%9E%90/image-20230131201508526.png" style="zoom:80%;"><h3 id="函数预解析（函数提升）"><a href="#函数预解析（函数提升）" class="headerlink" title="函数预解析（函数提升）"></a>函数预解析（函数提升）</h3><p>​       就是把所有的函数声明提升到当前作用域的最前面</p><p>案例：</p><p>  <code>var num = 10;</code></p><p>​    <code>fun();</code></p><p>​    <code>function fun() &#123;</code></p><p>​      <code>console.log(num);</code></p><p>​      <code>var num = 20;</code></p><p>​    <code>&#125;</code></p><p>​    <code>//相当于执行如下操作：</code></p><p>​    <code>var num;</code></p><p>​    <code>function fun() &#123;</code></p><p>​      <code>var num;</code></p><p>​      <code>console.log(num);  //就近原则，num=undefined</code></p><p>​      <code>num = 20;</code></p><p>​    <code>&#125;</code></p><p>​    <code>num = 10;</code></p><p>​    <code>fun();</code></p><img src="/2023/02/01/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%A2%84%E8%A7%A3%E6%9E%90/image-20230131204651732.png" style="zoom:80%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS作用域&quot;&gt;&lt;a href=&quot;#JS作用域&quot; class=&quot;headerlink&quot; title=&quot;JS作用域&quot;&gt;&lt;/a&gt;JS作用域&lt;/h1&gt;&lt;h2 id=&quot;1-作用域&quot;&gt;&lt;a href=&quot;#1-作用域&quot; class=&quot;headerlink&quot; title=&quot;1. </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——对象</title>
    <link href="http://localhost:4000/2023/01/31/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/"/>
    <id>http://localhost:4000/2023/01/31/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/</id>
    <published>2023-01-31T15:56:46.000Z</published>
    <updated>2023-01-31T16:00:24.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-什么是对象"><a href="#1-什么是对象" class="headerlink" title="1. 什么是对象"></a>1. 什么是对象</h2><p>对象：对象是一个具体的事物。在js中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串，数值，数组，函数等。</p><p>对象由属性和方法组成</p><ul><li>属性：事物的特征，在对象中用属性来表示（常用名词）</li><li>方法：事物的行为，在对象中用方法来表示（常用名词）</li></ul><h2 id="2-创建对象的方式"><a href="#2-创建对象的方式" class="headerlink" title="2. 创建对象的方式"></a>2. 创建对象的方式</h2><p>三种方法：</p><ul><li>利用字面量创建对象</li><li>利用new object创建对象</li><li>利用构造函数创建对象</li></ul><h3 id="2-1-利用字面量创建对象"><a href="#2-1-利用字面量创建对象" class="headerlink" title="2.1 利用字面量创建对象"></a>2.1 利用字面量创建对象</h3><p><code>var 对象名 = &#123;</code></p><p><code>属性1 : 属性值1,</code></p><p><code>属性2 : 属性值2,</code></p><p><code>方法名 : 匿名函数function()&#123;</code></p><p><code>&#125;</code></p><p><code>...</code></p><p><code>&#125;;</code></p><p>注意：</p><ul><li>里面的属性或者方法采取键值对的方法 键-属性名： 值-属性值</li><li>多个属性或者方法中间用逗号隔开</li><li>方法冒号后面跟的是一个匿名函数</li></ul><h4 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h4><p>调用对象的属性：</p><p><code>对象名.属性名    // 例如：obj.uname</code></p><p><code>对象名[&#39;属性名&#39;]      //例如：obj[&#39;uname&#39;]</code></p><ul><li>两种方法都很重要</li></ul><p>调用对象的方法：</p><p><code>对象名.方法名()</code></p><ul><li>方法后面不要忘记加括号</li></ul><h4 id="变量、属性、函数、方法的区别"><a href="#变量、属性、函数、方法的区别" class="headerlink" title="变量、属性、函数、方法的区别"></a>变量、属性、函数、方法的区别</h4><p><strong>变量和属性</strong></p><p>变量和属性都是用来存储数据的</p><p>变量单独声明并赋值，使用的时候直接写变量名，单独存在</p><p>属性在对象里，不需要声明，使用的时候必须是 对象.属性</p><p><strong>函数和方法</strong></p><p>函数和方法都是实现某种功能的</p><p>函数是单独声明 并且调用的</p><p>方法在对象里，调用的时候是 对象.方法()</p><h3 id="2-2-利用new-Object创建对象"><a href="#2-2-利用new-Object创建对象" class="headerlink" title="2.2 利用new Object创建对象"></a>2.2 利用new Object创建对象</h3><p><code>var 对象名 = new Object();</code></p><p>​       <code>对象名.属性 = 属性值;</code></p><p>​       <code>对象名.方法 = function()&#123;</code></p><p><code>&#125;</code></p><ul><li>我们是利用等号赋值的方法，添加对象的属性和方法</li><li>每个属性和方法之间用分号结束</li></ul><h3 id="2-3-利用构造函数创建对象"><a href="#2-3-利用构造函数创建对象" class="headerlink" title="2.3 利用构造函数创建对象"></a>2.3 利用构造函数创建对象</h3><p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new运算符一起使用。我们可以把对象中的一些公共属性和方法抽取出来，然后封装到这个函数里面</p><p><code>function 构造函数名()&#123;</code></p><p>​    <code>this.属性 = 属性值;</code></p><p>​    <code>this.方法 = function()&#123;</code></p><p>​    <code>&#125;</code></p><p><code>&#125;</code></p><p><code>new 构造函数名();  //调用</code></p><p>输入数据：<code>var 对象名 = 构造函数名(实参);</code></p><p>输出数据：<code>console.log(对象名.属性）；</code></p><p>示例：</p><img src="/2023/01/31/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/image-20230131224659890.png" style="zoom:80%;"><img src="/2023/01/31/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/image-20230131235148800.png" style="zoom:80%;"><p>结果：</p><img src="/2023/01/31/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/image-20230131230446520.png" style="zoom:80%;"><p>注意：</p><ul><li><p>构造函数不需要return就可以返回结果</p></li><li><p><strong>构造函数名 首字母要大写</strong></p></li><li><p>调用构造函数 必须使用new</p></li><li><p>只要new Star() 调用函数就创建了一个对象 </p></li><li><p>属性和方法的前面必须添加this</p></li><li><p>构造函数法实际上是将属性名以及对应的参数名装入了一个函数内，外部传入参数调用这个函数，通过获取属性得到相应的属性值</p></li></ul><h3 id="2-4-对象创建方法总结"><a href="#2-4-对象创建方法总结" class="headerlink" title="2.4 对象创建方法总结"></a>2.4 对象创建方法总结</h3><p><img src="/2023/01/31/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h1&gt;&lt;h2 id=&quot;1-什么是对象&quot;&gt;&lt;a href=&quot;#1-什么是对象&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是对象&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——函数</title>
    <link href="http://localhost:4000/2023/01/31/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/"/>
    <id>http://localhost:4000/2023/01/31/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/</id>
    <published>2023-01-31T06:48:58.000Z</published>
    <updated>2023-01-31T11:26:12.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-函数的概念"><a href="#1-函数的概念" class="headerlink" title="1. 函数的概念"></a>1. 函数的概念</h2><p>函数：封装了一段可以被重复执行的代码块，目的是让代码可以重复使用</p><h2 id="2-函数的使用"><a href="#2-函数的使用" class="headerlink" title="2. 函数的使用"></a>2. 函数的使用</h2><p>先声明，后调用</p><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p><code>function 函数名()&#123;</code></p><p><code>函数体</code></p><p><code>&#125;</code></p><p>注意：</p><ul><li>function是声明函数的关键字</li><li>函数是做某件事情，函数名一般是动词</li><li>函数不调用，自己不执行</li></ul><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p><code>函数名();</code></p><p>注意：</p><ul><li>调用函数的时候不要忘记加小括号</li></ul><h3 id="函数的封装"><a href="#函数的封装" class="headerlink" title="函数的封装"></a>函数的封装</h3><p>把一个或多个功能通过函数的方式封装起来</p><h2 id="3-函数的参数"><a href="#3-函数的参数" class="headerlink" title="3. 函数的参数"></a>3. 函数的参数</h2><h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p><code>function 函数名(形参1，形参2...)&#123;</code></p><p><code>函数体</code></p><p><code>&#125;</code></p><p><code>函数名(实参1，实参2...);</code></p><ul><li>声明函数的括号里是形参（形式上的参数）</li><li>调用函数的括号里是实参（实际的参数）</li></ul><h3 id="形参与实参的执行过程"><a href="#形参与实参的执行过程" class="headerlink" title="形参与实参的执行过程"></a>形参与实参的执行过程</h3><p>形参是接受实参的，形参类似于变量，只不过不需要声明，由实参在调用时给它赋值</p><p>函数的参数可以有可以有也可以没有，个数不限</p><h3 id="形参于实参的个数不匹配问题"><a href="#形参于实参的个数不匹配问题" class="headerlink" title="形参于实参的个数不匹配问题"></a>形参于实参的个数不匹配问题</h3><p>如果实参的个数与形参的个数一致，则正常输出结果</p><p>如果实参的个数多于形参的个数，则实参与形参按顺序匹配</p><p>如果实参的个数少于形参的个数，则多出来的形参可以看作不用声明的变量，结果就是undefined</p><p><img src="/2023/01/31/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/01.png"></p><h2 id="4-函数的返回值return"><a href="#4-函数的返回值return" class="headerlink" title="4. 函数的返回值return"></a>4. 函数的返回值return</h2><p>函数不应该有输出语句，而应该把结果返回给调用者</p><h3 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h3><p><code>function 函数名() &#123;</code></p><p>​      <code>return 需要返回的结果；</code></p><p><code>&#125;</code></p><p><code>函数名();</code></p><p>注意：</p><ul><li>函数只是实现某些功能，最终的结果需要返回给函数的调用者 函数名()</li><li>只要函数遇到return，就把后面的结果返回给函数的调用者，函数名() &#x3D; return后面的结果</li></ul><p>示例：</p><p>​    <code>function getResult() &#123;</code></p><p>​      <code>return 666;</code></p><p>​    <code>&#125;</code></p><p>​    <code>getResult();</code></p><p>​    <code>console.log(getResult());</code></p><p>技巧：</p><p><code>function getMax(arr) &#123;//接受一个数组</code></p><p>​      <code>var max = arr[0];</code></p><p>​      <code>for (var i = 1; i &lt; arr.length; i++) &#123;</code></p><p>​        <code>if (max &lt; arr[i]) &#123;</code></p><p>​          <code>max = arr[i];</code></p><p>​        <code>&#125;</code></p><p>​      <code>&#125;</code></p><p>​      <code>return max;</code></p><p>​    <code>&#125;</code></p><p>​    <code>//在实际开发里面，经常用一个变量来接受函数的返回结果</code></p><p>​    <code>var re = getMax([5, 2, 99, 101, 67, 77]);</code></p><p>​    <code>console.log(re);</code></p><h3 id="return终止函数"><a href="#return终止函数" class="headerlink" title="return终止函数"></a>return终止函数</h3><ul><li><p>return之后的代码不再执行，所以return一般放在函数的最后</p></li><li><p>return一次只能返回一个值</p></li></ul><h3 id="函数没有return返回undefine"><a href="#函数没有return返回undefine" class="headerlink" title="函数没有return返回undefine"></a>函数没有return返回undefine</h3><p>函数如果有return，则返回后面的值，如果没有，则返回undefined</p><h3 id="break-continue-return的区别"><a href="#break-continue-return的区别" class="headerlink" title="break,continue,return的区别"></a>break,continue,return的区别</h3><p><img src="/2023/01/31/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/02.png"></p><h2 id="5-arguement的使用"><a href="#5-arguement的使用" class="headerlink" title="5. arguement的使用"></a>5. arguement的使用</h2><p>当我们不确定有多少个参数传递的时候，可以通过arguement来获取。在js中，arguement实际上是当前函数的一个内置对象，所有函数都内置了一个arguement对象，arguement对象中存储了传递的所有实参</p><p>示例：</p><p> <code>function fn() &#123;</code></p><p>​      <code>console.log(arguement); //里面存储了所有传递过来的实参</code></p><p>​       <code>console.log(arguement.length);   //具有length属性</code></p><p>​    <code>&#125;</code></p><p>​    <code>fn(1,2,3)</code>;</p><p>arguement展示形式是一个伪数组，因此可以进行遍历，具有如下特点：</p><ul><li>具有length属性</li><li>按索引方式存储数据</li><li>不具有数组的push,pop等方法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;h2 id=&quot;1-函数的概念&quot;&gt;&lt;a href=&quot;#1-函数的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 函数的概念&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——数组</title>
    <link href="http://localhost:4000/2023/01/29/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
    <id>http://localhost:4000/2023/01/29/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</id>
    <published>2023-01-29T07:16:51.000Z</published>
    <updated>2023-01-31T07:31:04.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-数组的概念"><a href="#1-数组的概念" class="headerlink" title="1.数组的概念"></a>1.数组的概念</h2><p>一组数据的集合，可以存储在单个变量下</p><h2 id="2-创建数组"><a href="#2-创建数组" class="headerlink" title="2.创建数组"></a>2.创建数组</h2><p>方法：</p><ol><li><p>利用new创建数组</p><p><code>var arr = new Array();</code></p></li><li><p>利用数组字面量创建数组</p></li></ol><p>​        <code>//1.使用数组字面量方式创建空的数组</code></p><p>​            <code>var 数组名 = [];</code></p><p>​        <code>//2.使用数组字面量方式创建带初始值的数组</code></p><p>​            <code>var 数组名 =[&#39;小白&#39;,&#39;小黑&#39;,&#39;大黄&#39;,&#39;瑞奇&#39;];</code></p><ul><li>数组里面的数据一定要用逗号分隔</li><li>数组里面的数据称为数组元素</li><li>字面量是使用最多的方式</li><li>数组中的数据可以存放<strong>任意类型</strong>，数字型，字符型，布尔型，运算，函数等。</li></ul><h2 id="3-获取数组元素"><a href="#3-获取数组元素" class="headerlink" title="3.获取数组元素"></a>3.获取数组元素</h2><p>数组的索引：</p><p>用来访问数组元素的序号（数组下标从0开始）</p><p>元素获取：</p><p><code>//定义数组</code></p><p><code>var arrStus = [1,2,3];</code></p><p><code>//获取数组中的第二个元素</code></p><p><code>alert(arrStus[1]);</code></p><p><img src="/2023/01/29/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/01.png"></p><h2 id="4-遍历数组"><a href="#4-遍历数组" class="headerlink" title="4.遍历数组"></a>4.遍历数组</h2><p>如何把数组中全部元素取出来？</p><p>数组名[索引]的方法不够简便</p><p><strong>遍历：</strong>就是把数组中的每个元素从头到尾访问一次</p><p>示例：</p><p>  <code>var arr = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</code></p><p>​    <code>for (var i = 0; i &lt; 3; i++) &#123;</code></p><p>​      <code>console.log(arr[i]);</code></p><p>​    <code>&#125;</code></p><p><strong>数组长度</strong></p><p>数组名.length</p><p>注意：</p><ul><li><strong>数组长度是元素的个数</strong></li></ul><h3 id="计算数组的和及平均值"><a href="#计算数组的和及平均值" class="headerlink" title="计算数组的和及平均值"></a>计算数组的和及平均值</h3><p><img src="/2023/01/29/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/02.png"></p><h2 id="5-数组中新增元素"><a href="#5-数组中新增元素" class="headerlink" title="5.数组中新增元素"></a>5.数组中新增元素</h2><p>可以通过修改length长度及索引号增加数组元素</p><h3 id="修改length长度"><a href="#修改length长度" class="headerlink" title="修改length长度"></a>修改length长度</h3><p>可以通过修改length属性达到扩容的目的</p><p>示例：</p><p><code>var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];</code></p><p>​    <code>console.log(arr.length);</code></p><p>​    <code>arr.length = 5;  //把数组的长度修改为5，里面应该有五个元素</code></p><p>​    <code>console.log(arr[5]); //undefined</code></p><h3 id="修改数组索引新增数组元素"><a href="#修改数组索引新增数组元素" class="headerlink" title="修改数组索引新增数组元素"></a>修改数组索引新增数组元素</h3><p>​    <code>//修改索引号</code></p><p>​    <code>var arr1 = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];</code></p><p>​    <code>arr1[4] = &#39;orange&#39;;  //追加数组元素</code></p><p>​    <code>console.log(arr1);</code> </p><p>​    <code>arr1[1] = &#39;black&#39;;  //替换数组元素</code></p><p>​    <code>console.log(arr1);</code>  </p><p>​    <code>arr1 = &#39;white&#39;;  //不要给数组名赋值，否则里面的数组元素会被覆盖</code></p><p>​    <code>console.log(arr1)</code> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;h2 id=&quot;1-数组的概念&quot;&gt;&lt;a href=&quot;#1-数组的概念&quot; class=&quot;headerlink&quot; title=&quot;1.数组的概念&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
</feed>
