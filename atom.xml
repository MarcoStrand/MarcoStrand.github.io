<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MarcoStrand&#39;s Blog</title>
  
  
  <link href="http://localhost:4000/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2023-01-31T07:10:04.101Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>Liu Hanzhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScipt学习笔记——函数</title>
    <link href="http://localhost:4000/2023/01/31/JavaScipt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/"/>
    <id>http://localhost:4000/2023/01/31/JavaScipt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/</id>
    <published>2023-01-31T06:48:58.000Z</published>
    <updated>2023-01-31T07:10:04.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-函数的概念"><a href="#1-函数的概念" class="headerlink" title="1. 函数的概念"></a>1. 函数的概念</h2><p>函数：封装了一段可以被重复执行的代码块，目的是让代码可以重复使用</p><h2 id="2-函数的使用"><a href="#2-函数的使用" class="headerlink" title="2. 函数的使用"></a>2. 函数的使用</h2><p>先声明，后调用</p><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p><code>function 函数名()&#123;</code></p><p><code>函数体</code></p><p><code>&#125;</code></p><p>注意：</p><ul><li>function是声明函数的关键字</li><li>函数是做某件事情，函数名一般是动词</li><li>函数不调用，自己不执行</li></ul><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p><code>函数名();</code></p><p>注意：</p><ul><li>调用函数的时候不要忘记加小括号</li></ul><h3 id="函数的封装"><a href="#函数的封装" class="headerlink" title="函数的封装"></a>函数的封装</h3><p>把一个或多个功能通过函数的方式封装起来</p><h2 id="3-函数的参数"><a href="#3-函数的参数" class="headerlink" title="3. 函数的参数"></a>3. 函数的参数</h2><h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p><code>function 函数名(形参1，形参2...)&#123;</code></p><p><code>函数体</code></p><p><code>&#125;</code></p><p><code>函数名(实参1，实参2...);</code></p><ul><li>声明函数的括号里是形参（形式上的参数）</li><li>调用函数的括号里是实参（实际的参数）</li></ul><h3 id="形参与实参的执行过程"><a href="#形参与实参的执行过程" class="headerlink" title="形参与实参的执行过程"></a>形参与实参的执行过程</h3><p>形参是接受实参的，形参类似于变量，只不过不需要声明，由实参在调用时给它赋值</p><p>函数的参数可以有可以有也可以没有，个数不限</p><h3 id="形参于实参的个数不匹配问题"><a href="#形参于实参的个数不匹配问题" class="headerlink" title="形参于实参的个数不匹配问题"></a>形参于实参的个数不匹配问题</h3><p>如果实参的个数与形参的个数一致，则正常输出结果</p><p>如果实参的个数多于形参的个数，则实参与形参按顺序匹配</p><p>如果实参的个数少于形参的个数，则多出来的形参可以看作不用声明的变量，结果就是undefined</p><p><img src="/2023/01/31/JavaScipt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/01.png"></p><h2 id="4-函数的返回值return"><a href="#4-函数的返回值return" class="headerlink" title="4. 函数的返回值return"></a>4. 函数的返回值return</h2><p>函数不应该有输出语句，而应该把结果返回给调用者</p><h3 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h3><p><code>function 函数名() &#123;</code></p><p>​      <code>return 需要返回的结果；</code></p><p><code>&#125;</code></p><p><code>函数名();</code></p><p>注意：</p><ul><li>函数只是实现某些功能，最终的结果需要返回给函数的调用者 函数名()</li><li>只要函数遇到return，就把后面的结果返回给函数的调用者，函数名() &#x3D; return后面的结果</li></ul><p>示例：</p><p>​    <code>function getResult() &#123;</code></p><p>​      <code>return 666;</code></p><p>​    <code>&#125;</code></p><p>​    <code>getResult();</code></p><p>​    <code>console.log(getResult());</code></p><p>技巧：</p><p><code>function getMax(arr) &#123;//接受一个数组</code></p><p>​      <code>var max = arr[0];</code></p><p>​      <code>for (var i = 1; i &lt; arr.length; i++) &#123;</code></p><p>​        <code>if (max &lt; arr[i]) &#123;</code></p><p>​          <code>max = arr[i];</code></p><p>​        <code>&#125;</code></p><p>​      <code>&#125;</code></p><p>​      <code>return max;</code></p><p>​    <code>&#125;</code></p><p>​    <code>//在实际开发里面，经常用一个变量来接受函数的返回结果</code></p><p>​    <code>var re = getMax([5, 2, 99, 101, 67, 77]);</code></p><p>​    <code>console.log(re);</code></p><h3 id="return终止函数"><a href="#return终止函数" class="headerlink" title="return终止函数"></a>return终止函数</h3><ul><li><p>return之后的代码不再执行，所以return一般放在函数的最后</p></li><li><p>return一次只能返回一个值</p></li></ul><h3 id="函数没有return返回undefine"><a href="#函数没有return返回undefine" class="headerlink" title="函数没有return返回undefine"></a>函数没有return返回undefine</h3><p>函数如果有return，则返回后面的值，如果没有，则返回undefined</p><h3 id="break-continue-return的区别"><a href="#break-continue-return的区别" class="headerlink" title="break,continue,return的区别"></a>break,continue,return的区别</h3><p><img src="/2023/01/31/JavaScipt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/02.png"></p><h2 id="5-arguement的使用"><a href="#5-arguement的使用" class="headerlink" title="5. arguement的使用"></a>5. arguement的使用</h2><p>当我们不确定有多少个参数传递的时候，可以通过arguement来获取。在js中，arguement实际上是当前函数的一个内置对象，所有函数都内置了一个arguement对象，arguement对象中存储了传递的所有实参</p><p>示例：</p><p> <code>function fn() &#123;</code></p><p>​      <code>console.log(arguement); //里面存储了所有传递过来的实参</code></p><p>​       <code>console.log(arguement.length);   //具有length属性</code></p><p>​    <code>&#125;</code></p><p>​    <code>fn(1,2,3)</code>;</p><p>arguement展示形式是一个伪数组，因此可以进行遍历，具有如下特点：</p><ul><li>具有length属性</li><li>按索引方式存储数据</li><li>不具有数组的push,pop等方法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;h2 id=&quot;1-函数的概念&quot;&gt;&lt;a href=&quot;#1-函数的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 函数的概念&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
